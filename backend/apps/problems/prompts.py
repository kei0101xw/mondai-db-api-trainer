def build_problem_generation_prompt(difficulty: str, app_scale: str, mode: str) -> str:
    """
    問題生成用のプロンプトを構築する

    Args:
        difficulty: 難易度 (easy/medium/hard)
        app_scale: アプリ規模 (small/medium/large)
        mode: モード (db_only/api_only/both)

    Returns:
        Gemini API に投げるプロンプト文字列
    """

    # 難易度の説明
    difficulty_desc = {
        "easy": "初心者向け。基本的なテーブル設計やCRUD APIのみ。",
        "medium": "中級者向け。リレーション、インデックス、複雑なクエリを含む。",
        "hard": "上級者向け。パフォーマンス最適化、セキュリティ、スケーラビリティを考慮。",
    }

    # アプリ規模の説明
    scale_desc = {
        "small": "小規模（5テーブル以下、5エンドポイント以下）",
        "medium": "中規模（5〜10テーブル、10〜15エンドポイント）",
        "large": "大規模（10テーブル以上、15エンドポイント以上）",
    }

    # モードに応じた問題タイプ
    mode_instruction = {
        "db_only": """
# 問題タイプ
- DB設計問題のみを生成してください

# 期待する出力
"problems" 配列には1つの要素（problem_type: "db"）のみを含めてください。
""",
        "api_only": """
# 問題タイプ
- API設計問題のみを生成してください

# 期待する出力
"problems" 配列には API設計問題（problem_type: "api"）を1問以上含めてください。

## API問題の分割方針
API設計問題は、アプリの機能ごとに別々の小問として生成してください。

例：SNSアプリの場合
- order_index: 1 → ユーザー管理API（ユーザー登録、ログイン、プロフィール取得等）
- order_index: 2 → 投稿管理API（投稿作成、投稿一覧取得、投稿削除等）
- order_index: 3 → いいね機能API（いいね追加、いいね取得等）
- order_index: 4 → フォロー機能API（フォロー、フォロワー一覧等）

各API問題（小問）では、その機能に関連するエンドポイント群をまとめて設計させてください。
アプリ規模に応じて適切な数の小問を生成してください（small: 2-3問、medium: 3-5問、large: 5-7問程度）。
""",
        "both": """
# 問題タイプ
- DB設計問題とAPI設計問題の両方を生成してください

# 期待する出力
"problems" 配列には以下の要素を含めてください：
1. DB設計問題（problem_type: "db", order_index: 1）を1問
2. API設計問題（problem_type: "api", order_index: 2以降）を機能ごとに小問として複数生成

## API問題の分割方針
API設計問題は、アプリの機能ごとに別々の小問として生成してください。

例：SNSアプリの場合
- order_index: 2 → ユーザー管理API（ユーザー登録、ログイン、プロフィール取得等）
- order_index: 3 → 投稿管理API（投稿作成、投稿一覧取得、投稿削除等）
- order_index: 4 → いいね機能API（いいね追加、いいね取得等）
- order_index: 5 → フォロー機能API（フォロー、フォロワー一覧等）

各API問題（小問）では、その機能に関連するエンドポイント群をまとめて設計させてください。
アプリ規模に応じて適切な数の小問を生成してください（small: 2-3問、medium: 3-5問、large: 5-7問程度）。

※ 必ずDB問題を先頭に配置してください。
""",
    }

    prompt = f"""あなたはバックエンドエンジニア向けの問題作成専門家です。
以下の条件に基づいて、データベース設計・API設計の練習問題を生成してください。

# 条件
- 難易度: {difficulty} ({difficulty_desc.get(difficulty, "")})
- アプリ規模: {app_scale} ({scale_desc.get(app_scale, "")})
- モード: {mode}

{mode_instruction.get(mode, "")}

# アプリの題材例
- SNSアプリ（投稿、いいね、フォロー機能）
- ECサイト（商品、カート、注文機能）
- タスク管理アプリ（プロジェクト、タスク、担当者管理）
- ブログシステム（記事、カテゴリ、コメント機能）
- 予約システム（施設、予約枠、予約管理）

上記はあくまで例です。他の現実的なWebアプリの題材でも構いません。

# 出力形式（JSON）
必ず以下のJSON形式で出力してください。JSONのみを出力し、それ以外の説明文は含めないでください。

mode=both の場合は、API問題を機能ごとに分けて生成してください。

```json
{{
  "title": "題材のタイトル（例：SNSアプリ）",
  "description": "アプリの概要説明。どのような機能を持つアプリか詳しく記述。",
  "problems": [
    {{
      "problem_type": "db",
      "order_index": 1,
      "problem_body": "このアプリケーション全体のデータベース設計を行ってください。\\n\\n以下の要件を満たすデータベース設計を行ってください。\\n\\n■要件\\n- 主要エンティティと関係（リレーション）\\n- カラム（型、必須/任意、制約）\\n- 主キー/外部キー、ユニーク制約、NOT NULL、CHECK など\\n- 重要な検索条件がある場合はインデックス方針\\n- 削除方針（論理削除/物理削除）や履歴が必要ならその要件\\n\\n■回答フォーマット\\n- SQLのCREATE TABLE文で回答してください。"
    }},
    {{
      "problem_type": "api",
      "order_index": 2,
      "problem_body": "【機能名（例：ユーザー管理機能）】のAPIを設計してください。\\n\\n以下の要件を満たすAPIを設計し、擬似コードで実装方針を示してください。\\n\\n■要件\\n- この機能で必要な操作（作成/取得/更新/削除、状態変更など）\\n- 一覧取得の条件（フィルタ、ソート、ページング）\\n- 認証・認可（誰が何をできるか）\\n- 入出力の項目（必須/任意、型、制約）\\n- エラー条件（400/401/403/404/409などが起きる具体条件）\\n- 可能なら非機能要件（冪等性、レート制限、監査ログ等）\\n\\n■回答フォーマット\\n1. API設計情報\\n- [METHOD] [PATH] : 目的\\n  - 認証/認可：\\n  - Request：\\n  - Response：\\n  - エラー：\\n（必要なエンドポイント分だけ繰り返す）\\n\\n2. 疑似コード（言語非依存）\\n- handler/controller相当の疑似コード\\n- DBアクセスや外部サービス呼び出しは抽象化可"
    }},
    {{
      "problem_type": "api",
      "order_index": 3,
      "problem_body": "【投稿管理機能】のAPIを設計してください。\\n\\n以下の要件を満たすAPIを設計し、擬似コードで実装方針を示してください。\\n\\n■要件\\n- 投稿の作成・取得・更新・削除\\n- タイムライン形式での投稿一覧取得（フォロー中ユーザーの投稿のみ）\\n- ページング対応（カーソルベース推奨）\\n- 投稿者本人のみ編集・削除可能\\n\\n■回答フォーマット\\n1. API設計情報\\n2. 疑似コード"
    }}
  ]
}}
```

# 注意事項
- problem_body には具体的な要件を詳しく記述してください
- DB設計問題では、アプリケーション全体のテーブル構造、カラム、制約、リレーションを明確に示してください
- API設計問題は、機能ごとに別々の小問として生成してください。各小問では、その機能に関連するエンドポイント群をまとめて設計させます。
- problem_body は「要件・制約・ユースケース」のみを書いてください。解答（設計案）に当たる具体例は書かないでください。
- API設計問題では、HTTPメソッド（GET/POST等）や具体的なURLパス（/users/:id等）を問題文に直接書かないでください。代わりに「必要な操作（例：投稿作成、一覧取得…）」「期待する入出力」「認可要件」「一覧の絞り込み/ページング条件」などを要件として列挙してください。
- API設計問題の回答では、以下の2点を必ず含める形式としてください。
  1. API設計情報（HTTPメソッド、エンドポイント、役割、認証、入出力）
  2. 上記設計に基づく疑似コード（言語非依存で可）
- 難易度とアプリ規模に応じて、問題の複雑さとAPI小問の数を調整してください
- 必ずJSONのみを出力してください（```json マーカーも不要です）
"""

    return prompt


def build_grading_prompt(problem_type: str, problem_body: str, answer_body: str) -> str:
    """
    採点用のプロンプトを構築する

    Args:
        problem_type: 問題タイプ (db/api)
        problem_body: 問題本文
        answer_body: ユーザーの回答

    Returns:
        Gemini API に投げるプロンプト文字列
    """

    problem_type_name = "データベース設計" if problem_type == "db" else "API設計"

    prompt = f"""あなたは経験豊富なバックエンドエンジニアで、{problem_type_name}問題の採点を行う専門家です。

# 採点対象

## 問題
{problem_body}

## 受講者の回答
{answer_body}

# 採点基準

以下の観点で採点してください：

## {problem_type_name}問題の評価ポイント
"""

    if problem_type == "db":
        prompt += """
- テーブル設計が要件を満たしているか
- 主キー、外部キー、インデックスが適切に設定されているか
- 正規化が適切に行われているか（過度な正規化や非正規化の問題がないか）
- データ型の選択が適切か
- NOT NULL制約、UNIQUE制約、CHECK制約などが適切か
- リレーション（1対多、多対多など）が正しくモデル化されているか
- スケーラビリティやパフォーマンスへの配慮があるか
- 命名規則が一貫しているか
"""
    else:  # api
        prompt += """
- エンドポイント設計が要件を満たしているか
- HTTPメソッド（GET/POST/PUT/DELETE等）の選択が適切か
- URLパス設計がRESTfulか、リソース指向になっているか
- リクエスト・レスポンスの項目が適切か
- 認証・認可の考慮があるか
- エラーハンドリングが適切か（ステータスコード、エラーレスポンス）
- ページング、フィルタリング、ソートなどの考慮があるか
- 冪等性やレート制限などの非機能要件への配慮があるか
- 疑似コードが設計と整合しているか
"""

    prompt += """
# 採点結果

採点結果を以下の3段階で評価してください：
- ○（2点）: 要件を満たしており、設計として十分に優れている
- △（1点）: 部分的に要件を満たしているが、改善の余地がある
- ×（0点）: 要件を満たしていない、または重大な設計上の問題がある

# 出力形式（JSON）

必ず以下のJSON形式で出力してください。JSONのみを出力し、それ以外の説明文は含めないでください。

```json
{
  "grade": 2,
  "model_answer": "模範解答をここに記述してください。問題の要件を完全に満たす設計例を示してください。",
  "explanation": "採点の根拠と、受講者の回答の良かった点・改善すべき点を具体的に説明してください。模範解答との比較も含めてください。"
}
```

# 注意事項
- grade は必ず 0, 1, 2 のいずれかの整数値を出力してください
- model_answer は受講者の回答を参照・コピーせず、問題の要件に基づいてゼロから作成してください
- 受講者の回答が優れていても、必ず独自の模範解答を示してください（受講者の回答をそのまま模範解答にしないでください）
- model_answer は具体的かつ実践的な内容にしてください
- explanation は建設的なフィードバックを心がけ、なぜその採点になったのか明確に説明してください
- 必ずJSONのみを出力してください（```json マーカーも不要です）
"""

    return prompt


def build_batch_grading_prompt(problems_with_answers: list[dict]) -> str:
    """
    一括採点用のプロンプトを構築する

    Args:
        problems_with_answers: 問題と回答のペアリスト
            [
                {
                    "order_index": 1,
                    "problem_type": "db",
                    "problem_body": "問題文",
                    "answer_body": "回答"
                },
                ...
            ]

    Returns:
        Gemini API に投げるプロンプト文字列
    """

    # 各問題の採点セクションを構築
    problems_section = ""
    for item in problems_with_answers:
        order_index = item["order_index"]
        problem_type = item["problem_type"]
        problem_type_name = "データベース設計" if problem_type == "db" else "API設計"
        problem_body = item["problem_body"]
        answer_body = item["answer_body"]

        problems_section += f"""
---
## 問題 {order_index}（{problem_type_name}問題）

### 問題文
{problem_body}

### 受講者の回答
{answer_body}

"""

    prompt = f"""あなたは経験豊富なバックエンドエンジニアで、データベース設計・API設計問題の採点を行う専門家です。

以下の複数の問題に対する受講者の回答を一括で採点してください。

# 採点対象
{problems_section}

# 採点基準

各問題を以下の観点で採点してください：

## データベース設計問題の評価ポイント
- テーブル設計が要件を満たしているか
- 主キー、外部キー、インデックスが適切に設定されているか
- 正規化が適切に行われているか（過度な正規化や非正規化の問題がないか）
- データ型の選択が適切か
- NOT NULL制約、UNIQUE制約、CHECK制約などが適切か
- リレーション（1対多、多対多など）が正しくモデル化されているか
- スケーラビリティやパフォーマンスへの配慮があるか
- 命名規則が一貫しているか

## API設計問題の評価ポイント
- エンドポイント設計が要件を満たしているか
- HTTPメソッド（GET/POST/PUT/DELETE等）の選択が適切か
- URLパス設計がRESTfulか、リソース指向になっているか
- リクエスト・レスポンスの項目が適切か
- 認証・認可の考慮があるか
- エラーハンドリングが適切か（ステータスコード、エラーレスポンス）
- ページング、フィルタリング、ソートなどの考慮があるか
- 冪等性やレート制限などの非機能要件への配慮があるか
- 疑似コードが設計と整合しているか

# 採点結果

各問題の採点結果を以下の3段階で評価してください：
- ○（2点）: 要件を満たしており、設計として十分に優れている
- △（1点）: 部分的に要件を満たしているが、改善の余地がある
- ×（0点）: 要件を満たしていない、または重大な設計上の問題がある

# 出力形式（JSON）

必ず以下のJSON形式で出力してください。JSONのみを出力し、それ以外の説明文は含めないでください。
各問題の採点結果を results 配列に order_index 順で格納してください。

```json
{{
  "results": [
    {{
      "order_index": 1,
      "grade": 2,
      "model_answer": "問題1の模範解答をここに記述してください。問題の要件を完全に満たす設計例を示してください。",
      "explanation": "問題1の採点の根拠と、受講者の回答の良かった点・改善すべき点を具体的に説明してください。"
    }},
    {{
      "order_index": 2,
      "grade": 1,
      "model_answer": "問題2の模範解答をここに記述してください。",
      "explanation": "問題2の採点の根拠と、受講者の回答の良かった点・改善すべき点を具体的に説明してください。"
    }}
  ]
}}
```

# 注意事項
- results 配列には、入力された問題数と同じ数の要素を含めてください
- 各要素の order_index は入力された問題の order_index と一致させてください
- grade は必ず 0, 1, 2 のいずれかの整数値を出力してください
- model_answer は受講者の回答を参照・コピーせず、問題の要件に基づいてゼロから作成してください
- 受講者の回答が優れていても、必ず独自の模範解答を示してください（受講者の回答をそのまま模範解答にしないでください）
- model_answer は具体的かつ実践的な内容にしてください
- explanation は建設的なフィードバックを心がけ、なぜその採点になったのか明確に説明してください
- 必ずJSONのみを出力してください（```json マーカーも不要です）
"""

    return prompt
